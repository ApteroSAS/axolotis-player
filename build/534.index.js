/*!
 * 
 *   @aptero/axolotis-player v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
(self.webpackChunkaxolotis_player=self.webpackChunkaxolotis_player||[]).push([[534],{952:function(t,e,n){"use strict";n.d(e,{J0:function(){return a},Zy:function(){return y},b4:function(){return p}});var r=n(178),i=n(212),s=n(135),o={};let a=null,l=null,c=null,u=null;const b=4,h=-1;function p(t){let e=function(t){let e=(new s.N).setFromObject(t).faces,n=[],r=[];for(var o=0;o<e.length;o++){var a=e[o],l=a.edge;do{let t=l.head().point;n.push(t.x,t.y,t.z),r.push(a.normal.x,a.normal.y,a.normal.z),l=l.next}while(l!==a.edge)}const c=new i.BufferGeometry;return c.setAttribute("position",new i.Float32BufferAttribute(n,3)),c.setAttribute("normal",new i.Float32BufferAttribute(r,3)),c}(t).attributes.position.array,n=new a.btVector3(0,0,0),r=new a.btConvexHullShape;for(let t=0,i=e.length;t<i;t+=3){n.setValue(e[t],e[t+1],e[t+2]);let s=t>=i-3;r.addPoint(n,s)}return r}class y{static init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>{};r(o).then((e=>{a=e,t()}))}static CreateTrigger(t,e,n){const r=new a.btTransform;r.setIdentity(),e&&r.setOrigin(new a.btVector3(e.x,e.y,e.z)),n&&r.setRotation(new a.btQuaternion(n.x,n.y,n.z,n.w));const i=new a.btPairCachingGhostObject;return i.setCollisionShape(t),i.setCollisionFlags(b),i.setWorldTransform(r),i}static IsTriggerOverlapping(t,e){for(let n=0;n<t.getNumOverlappingObjects();n++){if(a.castObject(t.getOverlappingObject(n),a.btRigidBody)==e)return!0}return!1}static CastRay(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:h;l||(l=new a.btVector3,c=new a.btVector3,u=new a.ClosestRayResultCallback(l,c));const s=a.castObject(u,a.RayResultCallback);if(s.set_m_closestHitFraction(1),s.set_m_collisionObject(null),s.m_collisionFilterMask=i,l.setValue(e.x,e.y,e.z),c.setValue(n.x,n.y,n.z),u.get_m_rayFromWorld().setValue(e.x,e.y,e.z),u.get_m_rayToWorld().setValue(n.x,n.y,n.z),t.rayTest(l,c,u),u.hasHit()){if(r.intersectionPoint){const t=u.get_m_hitPointWorld();r.intersectionPoint.set(t.x(),t.y(),t.z())}if(r.intersectionNormal){const t=u.get_m_hitNormalWorld();r.intersectionNormal.set(t.x(),t.y(),t.z())}return r.collisionObject=s.get_m_collisionObject(),!0}return!1}}},703:function(t,e,n){"use strict";n.r(e),n.d(e,{AmmoPhysics:function(){return i},Factory:function(){return s}});var r=n(952);class i{constructor(){var t,e,n;n=(t,e)=>{},(e="physicsUpdate")in(t=this)?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n}async setupPhysics(){return new Promise((t=>{r.Zy.init((()=>{const e=new r.J0.btDefaultCollisionConfiguration,n=new r.J0.btCollisionDispatcher(e),i=new r.J0.btDbvtBroadphase,s=new r.J0.btSequentialImpulseConstraintSolver;this.physicsWorld=new r.J0.btDiscreteDynamicsWorld(n,i,s,e),this.physicsWorld.setGravity(new r.J0.btVector3(0,-9.81,0)),this.physicsWorld.getBroadphase().getOverlappingPairCache().setInternalGhostPairCallback(new r.J0.btGhostPairCallback),t(!0)}))}))}step(t){this.physicsWorld.stepSimulation(t,10)}getAmmo(){return r.J0}getType(){return i.name}}class s{async create(t){let e=await t.getService("@root/lib/modules/FrameLoop");const n=new i;return await n.setupPhysics(),(await e).addLoop(i.name,(t=>{n.step(.001*t)})),n}}},207:function(){},297:function(){}}]);
//# sourceMappingURL=534.index.js.map