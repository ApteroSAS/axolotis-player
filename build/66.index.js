/*!
 * 
 *   @aptero/axolotis-player v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
(self.webpackChunkaxolotis_player=self.webpackChunkaxolotis_player||[]).push([[66],{952:function(t,e,n){"use strict";n.d(e,{J0:function(){return a},Zy:function(){return b},b4:function(){return m}});var i=n(178),s=n(212),o=n(135),r={};let a=null,l=null,c=null,u=null;const h=4,d=-1;function m(t){let e=function(t){let e=(new o.N).setFromObject(t).faces,n=[],i=[];for(var r=0;r<e.length;r++){var a=e[r],l=a.edge;do{let t=l.head().point;n.push(t.x,t.y,t.z),i.push(a.normal.x,a.normal.y,a.normal.z),l=l.next}while(l!==a.edge)}const c=new s.BufferGeometry;return c.setAttribute("position",new s.Float32BufferAttribute(n,3)),c.setAttribute("normal",new s.Float32BufferAttribute(i,3)),c}(t).attributes.position.array,n=new a.btVector3(0,0,0),i=new a.btConvexHullShape;for(let t=0,s=e.length;t<s;t+=3){n.setValue(e[t],e[t+1],e[t+2]);let o=t>=s-3;i.addPoint(n,o)}return i}class b{static init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>{};i(r).then((e=>{a=e,t()}))}static CreateTrigger(t,e,n){const i=new a.btTransform;i.setIdentity(),e&&i.setOrigin(new a.btVector3(e.x,e.y,e.z)),n&&i.setRotation(new a.btQuaternion(n.x,n.y,n.z,n.w));const s=new a.btPairCachingGhostObject;return s.setCollisionShape(t),s.setCollisionFlags(h),s.setWorldTransform(i),s}static IsTriggerOverlapping(t,e){for(let n=0;n<t.getNumOverlappingObjects();n++){if(a.castObject(t.getOverlappingObject(n),a.btRigidBody)==e)return!0}return!1}static CastRay(t,e,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:d;l||(l=new a.btVector3,c=new a.btVector3,u=new a.ClosestRayResultCallback(l,c));const o=a.castObject(u,a.RayResultCallback);if(o.set_m_closestHitFraction(1),o.set_m_collisionObject(null),o.m_collisionFilterMask=s,l.setValue(e.x,e.y,e.z),c.setValue(n.x,n.y,n.z),u.get_m_rayFromWorld().setValue(e.x,e.y,e.z),u.get_m_rayToWorld().setValue(n.x,n.y,n.z),t.rayTest(l,c,u),u.hasHit()){if(i.intersectionPoint){const t=u.get_m_hitPointWorld();i.intersectionPoint.set(t.x(),t.y(),t.z())}if(i.intersectionNormal){const t=u.get_m_hitNormalWorld();i.intersectionNormal.set(t.x(),t.y(),t.z())}return i.collisionObject=o.get_m_collisionObject(),!0}return!1}}},169:function(t,e,n){"use strict";n.r(e),n.d(e,{Factory:function(){return r},default:function(){return a}});var i=n(952),s=n(595),o=n(987);class r{async create(t,e){let n=t.getFirstComponentByType(o.e.name),i=await n.getService("@root/lib/modules/three/ThreeLib"),s=await n.getService("@root/lib/modules/core/ammo/AmmoPhysics"),r=new a;return await r.loadScene(s,i),r}}class a{constructor(){}getType(){return"LevelSetup"}async loadScene(t,e){this.scene=e.scene,this.physicsWorld=t.physicsWorld,this.mesh=await(0,s.ev)("assets/static/demo2/level.glb"),this.mesh=this.mesh.scene,this.mesh.traverse((t=>{if((t.isMesh||t.isLight)&&(t.castShadow=!0),t.isMesh&&(t.receiveShadow=!0,this.setStaticCollider(t)),t.isLight){t.intensity=3;const e=t.shadow,n=e.camera;e.mapSize.width=3072,e.mapSize.height=3072,e.bias=-7e-5;const i=35,s=35;n.left=-i,n.right=i,n.top=s,n.bottom=-s}})),this.scene.add(this.mesh)}setStaticCollider(t){const e=(0,i.b4)(t),n=new i.J0.btTransform;n.setIdentity();const s=new i.J0.btDefaultMotionState(n),o=new i.J0.btVector3(0,0,0),r=new i.J0.btRigidBodyConstructionInfo(0,s,e,o),a=new i.J0.btRigidBody(r);a.mesh=t,this.physicsWorld.addRigidBody(a)}}},207:function(){},297:function(){}}]);
//# sourceMappingURL=66.index.js.map