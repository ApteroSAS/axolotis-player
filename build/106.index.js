/*!
 * 
 *   @aptero/axolotis-player v1.0.0
 *   https://github.com/ApteroSAS/axolotis-player
 *
 *   Copyright (c) Aptero (https://github.com/ApteroSAS/axolotis-player) and project contributors.
 *
 *   This source code is licensed under the MIT license found in the
 *   LICENSE file in the root directory of this source tree.
 *
 */
"use strict";(self.webpackChunkaxolotis_player=self.webpackChunkaxolotis_player||[]).push([[106],{106:function(t,e,n){n.r(e),n.d(e,{Factory:function(){return g},GLTFScene:function(){return h}});var r=n(212),a=n(217);class s extends r.DataTextureLoader{constructor(t){super(t),this.type=r.HalfFloatType}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let r=t.pos,a=-1,s=0,o="",i=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));for(;0>(a=i.indexOf("\n"))&&s<e&&r<t.byteLength;)o+=i,s+=i.length,r+=128,i+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));return-1<a&&(!1!==n&&(t.pos+=s+a+1),o+i.slice(0,a))},a=function(t,e,n,r){const a=t[e+3],s=Math.pow(2,a-128)/255;n[r+0]=t[e+0]*s,n[r+1]=t[e+1]*s,n[r+2]=t[e+2]*s},s=function(t,e,n,a){const s=t[e+3],o=Math.pow(2,s-128)/255;n[a+0]=r.DataUtils.toHalfFloat(Math.min(t[e+0]*o,65504)),n[a+1]=r.DataUtils.toHalfFloat(Math.min(t[e+1]*o,65504)),n[a+2]=r.DataUtils.toHalfFloat(Math.min(t[e+2]*o,65504))},o=new Uint8Array(t);o.pos=0;const i=function(t){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,i={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,u;if(t.pos>=t.byteLength||!(l=n(t)))return e(1,"no header found");if(!(u=l.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(i.valid|=1,i.programtype=u[1],i.string+=l+"\n";l=n(t),!1!==l;)if(i.string+=l+"\n","#"!==l.charAt(0)){if((u=l.match(r))&&(i.gamma=parseFloat(u[1],10)),(u=l.match(a))&&(i.exposure=parseFloat(u[1],10)),(u=l.match(s))&&(i.valid|=2,i.format=u[1]),(u=l.match(o))&&(i.valid|=4,i.height=parseInt(u[1],10),i.width=parseInt(u[2],10)),2&i.valid&&4&i.valid)break}else i.comments+=l+"\n";return 2&i.valid?4&i.valid?i:e(3,"missing image size specifier"):e(3,"missing format specifier")}(o);if(-1!==i){const t=i.width,n=i.height,l=function(t,n,r){const a=n;if(a<8||a>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(a!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const s=new Uint8Array(4*n*r);if(!s.length)return e(4,"unable to allocate buffer space");let o=0,i=0;const l=4*a,u=new Uint8Array(4),c=new Uint8Array(l);let p=r;for(;p>0&&i<t.byteLength;){if(i+4>t.byteLength)return e(1);if(u[0]=t[i++],u[1]=t[i++],u[2]=t[i++],u[3]=t[i++],2!=u[0]||2!=u[1]||(u[2]<<8|u[3])!=a)return e(3,"bad rgbe scanline format");let n,r=0;for(;r<l&&i<t.byteLength;){n=t[i++];const a=n>128;if(a&&(n-=128),0===n||r+n>l)return e(3,"bad scanline data");if(a){const e=t[i++];for(let t=0;t<n;t++)c[r++]=e}else c.set(t.subarray(i,i+n),r),r+=n,i+=n}const g=a;for(let t=0;t<g;t++){let e=0;s[o]=c[t+e],e+=a,s[o+1]=c[t+e],e+=a,s[o+2]=c[t+e],e+=a,s[o+3]=c[t+e],o+=4}p--}return s}(o.subarray(o.pos),t,n);if(-1!==l){let e,o,u,c;switch(this.type){case r.UnsignedByteType:e=l,o=r.RGBEFormat,u=r.UnsignedByteType;break;case r.FloatType:c=l.length/4;const t=new Float32Array(3*c);for(let e=0;e<c;e++)a(l,4*e,t,3*e);e=t,o=r.RGBFormat,u=r.FloatType;break;case r.HalfFloatType:c=l.length/4;const n=new Uint16Array(3*c);for(let t=0;t<c;t++)s(l,4*t,n,3*t);e=n,o=r.RGBFormat,u=r.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:i.string,gamma:i.gamma,exposure:i.exposure,format:o,type:u}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,a){return super.load(t,(function(t,n){switch(t.type){case r.UnsignedByteType:t.encoding=r.RGBEEncoding,t.minFilter=r.NearestFilter,t.magFilter=r.NearestFilter,t.generateMipmaps=!1,t.flipY=!0;break;case r.FloatType:case r.HalfFloatType:t.encoding=r.LinearEncoding,t.minFilter=r.LinearFilter,t.magFilter=r.LinearFilter,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,a)}}const o=function(){const t=new r.RawShaderMaterial({uniforms:{roughnessMap:{value:null},normalMap:{value:null},texelSize:{value:new r.Vector2(1,1)}},vertexShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",fragmentShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",blending:r.NoBlending,depthTest:!1,depthWrite:!1});return t.type="RoughnessMipmapper",t}(),i=new r.Mesh(new r.PlaneGeometry(2,2),o),l=new r.OrthographicCamera(0,1,0,1,0,1);let u=null,c=null;class p{constructor(t){c=t,c.compile(i,l)}generateMipmaps(t){if("roughnessMap"in t==!1)return;const{roughnessMap:e,normalMap:n}=t;if(null===e||null===n||!e.generateMipmaps||t.userData.roughnessUpdated)return;t.userData.roughnessUpdated=!0;let a=Math.max(e.image.width,n.image.width),s=Math.max(e.image.height,n.image.height);if(!r.MathUtils.isPowerOfTwo(a)||!r.MathUtils.isPowerOfTwo(s))return;const p=c.getRenderTarget(),g=c.autoClear;if(c.autoClear=!1,null!==u&&u.width===a&&u.height===s||(null!==u&&u.dispose(),u=new r.WebGLRenderTarget(a,s,{depthBuffer:!1}),u.scissorTest=!0),a!==e.image.width||s!==e.image.height){const n={wrapS:e.wrapS,wrapT:e.wrapT,magFilter:e.magFilter,minFilter:e.minFilter,depthBuffer:!1},o=new r.WebGLRenderTarget(a,s,n);o.texture.generateMipmaps=!0,c.setRenderTarget(o),t.roughnessMap=o.texture,t.metalnessMap==e&&(t.metalnessMap=t.roughnessMap),t.aoMap==e&&(t.aoMap=t.roughnessMap),t.roughnessMap.offset.copy(e.offset),t.roughnessMap.repeat.copy(e.repeat),t.roughnessMap.center.copy(e.center),t.roughnessMap.rotation=e.rotation,t.roughnessMap.image=e.image,t.roughnessMap.matrixAutoUpdate=e.matrixAutoUpdate,t.roughnessMap.matrix.copy(e.matrix)}o.uniforms.roughnessMap.value=e,o.uniforms.normalMap.value=n;const h=new r.Vector2(0,0),f=o.uniforms.texelSize.value;for(let e=0;a>=1&&s>=1;++e,a/=2,s/=2)f.set(1/a,1/s),0==e&&f.set(0,0),u.viewport.set(h.x,h.y,a,s),u.scissor.set(h.x,h.y,a,s),c.setRenderTarget(u),c.render(i,l),c.copyFramebufferToTexture(h,t.roughnessMap,e),o.uniforms.roughnessMap.value=t.roughnessMap;e!==t.roughnessMap&&e.dispose(),c.setRenderTarget(p),c.autoClear=g}dispose(){o.dispose(),i.geometry.dispose(),null!=u&&u.dispose()}}class g{async create(t){let e=await t.getService("@root/lib/modules/three/ThreeLib");return new h(e)}}class h{constructor(t){(new s).setPath("assets/static/demo/").load("royal_esplanade_1k.hdr",(function(e){e.mapping=r.EquirectangularReflectionMapping,t.scene.background=e,t.scene.environment=e;const n=new p(t.renderer);(new a.GLTFLoader).setPath("assets/static/demo/").load("DamagedHelmet.gltf",(function(e){e.scene.traverse((function(t){t.isMesh&&n.generateMipmaps(t.material)})),t.scene.add(e.scene),n.dispose()}))}))}getType(){return h.name}}}}]);
//# sourceMappingURL=106.index.js.map