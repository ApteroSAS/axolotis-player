{"version":3,"file":"342.index.js","mappings":"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","sources":["webpack://axolotis-player/./node_modules/phoenix/priv/static/phoenix.esm.js","webpack://axolotis-player/./src/lib/modules/spoke/PhoenixUtils.ts","webpack://axolotis-player/./src/lib/modules/spoke/SceneLoader.ts","webpack://axolotis-player/./src/lib/modules/spoke/SpokeRoomLoader.ts"],"sourcesContent":["// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || void 0;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n    req.onerror = () => {\n      callback && callback(null);\n    };\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry();\n  }\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => {\n              this.onmessage({ data: msg });\n            }, 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n        case 403:\n          this.onerror();\n          this.close();\n          break;\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n  close(_code, _reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  replaceTransport(newTransport) {\n    this.disconnect();\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    this.connectClock++;\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log(\"transport\", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.abnormalClose(\"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    clearTimeout(this.heartbeatTimer);\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    clearTimeout(this.heartbeatTimer);\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    if (this.isConnected()) {\n      this.conn.close(WS_CLOSE_NORMAL, reason);\n    }\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        clearTimeout(this.heartbeatTimer);\n        this.pendingHeartbeatRef = null;\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\nexport {\n  Channel,\n  LongPoll,\n  Presence,\n  serializer_default as Serializer,\n  Socket\n};\n//# sourceMappingURL=phoenix.esm.js.map\n","import { Socket } from \"phoenix\";\n\nlet configs = {\n  RETICULUM_SOCKET_SERVER_PORT: \"443\",\n  RETICULUM_SOCKET_SERVER: \"alphahub.aptero.co\", //TODO\n  RETICULUM_SOCKET_PROTOCOL: \"wss:\",\n};\n\nexport function createHubChannelParams(\n  authToken: string | null = null,\n  permsToken: string | null = null\n) {\n  /*{\n        \"profile\": {\n        \"avatarId\": \"https://hub.aptero.co/data/avatar/A031/base.glb\",\n            \"displayName\": \"Pierre\"\n    },\n        \"push_subscription_endpoint\": null,\n        \"auth_token\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXQiLCJleHAiOjE2MjM2Nzc4NzUsImlhdCI6MTYxNjQyMDI3NSwiaXNzIjoicmV0IiwianRpIjoiMTBkMWFkZmYtYjBlMi00N2RkLWFiMTgtMjY3MGY0ZDVhMTFkIiwibmJmIjoxNjE2NDIwMjc0LCJzdWIiOiI2NDA0MDcwNTA5NjYyNjk5NjEiLCJ0eXAiOiJhY2Nlc3MifQ.qp29Ip4AKkpRPtVVOUikytL1u-lGPJidUglsWlW8H9izgdRsoH_c0yZuA04Miwi6K2iN-GsoCr8Kd1fTH0yp2g\",\n        \"perms_token\": null,\n        \"context\": {\n        \"mobile\": false,\n            \"embed\": true\n    },\n        \"hub_invite_id\": null\n    }*/\n  const params = {\n    profile: {\n      avatarId: \"\",\n      displayName: \"\",\n    },\n    push_subscription_endpoint: null,\n    auth_token: null,\n    perms_token: null,\n    bot_access_key: null,\n    context: {\n      mobile: false,\n      embed: true,\n    },\n    hub_invite_id: null,\n  };\n\n  return params;\n}\n\nexport async function load(\n  hubid\n): Promise<{ data: any; hubPhxChannel: any; vapiddata: any }> {\n  const socket = await connectToReticulum();\n  socket.onClose((e) => {\n    console.error(e);\n  });\n\n  const { data, hubPhxChannel, vapiddata } = await new Promise(\n    (resolve, reject) => {\n      // Reticulum global channel\n      let retChannel = socket.channel(`ret`, { hub_id: hubid });\n      retChannel\n        .join()\n        .receive(\"ok\", (vapiddata) => {\n          const hubPhxChannel = socket.channel(\n            `hub:` + hubid,\n            createHubChannelParams()\n          );\n          hubPhxChannel\n            .join()\n            .receive(\"ok\", async (data) => {\n              resolve({ data, hubPhxChannel, vapiddata });\n            })\n            .receive(\"error\", (res) => {\n              reject(res);\n            });\n        })\n        .receive(\"error\", (res) => {\n          reject(res);\n        });\n    }\n  );\n  return { data, hubPhxChannel, vapiddata };\n}\n\nlet reticulumMeta: any = null;\nlet invalidatedReticulumMetaThisSession = false;\n\nlet directReticulumHostAndPort;\n\nasync function refreshDirectReticulumHostAndPort() {\n  const qs = new URLSearchParams(location.search);\n  let host = qs.get(\"phx_host\");\n  host = host || configs.RETICULUM_SOCKET_SERVER;\n  const port = configs.RETICULUM_SOCKET_SERVER_PORT;\n  directReticulumHostAndPort = { host, port };\n}\n\nexport async function invalidateReticulumMeta() {\n  invalidatedReticulumMetaThisSession = true;\n  reticulumMeta = null;\n}\n\n//TODO important function\nexport async function connectToReticulum(\n  debug = false,\n  params = null,\n  socketClass = Socket\n) {\n  const qs = new URLSearchParams(location.search);\n\n  const getNewSocketUrl = async () => {\n    await refreshDirectReticulumHostAndPort();\n    const { host, port } = directReticulumHostAndPort;\n    const protocol =\n      qs.get(\"phx_protocol\") ||\n      configs.RETICULUM_SOCKET_PROTOCOL ||\n      (document.location.protocol === \"https:\" ? \"wss:\" : \"ws:\");\n\n    return `${protocol}//${host}${port ? `:${port}` : \"\"}`;\n  };\n\n  const socketUrl = await getNewSocketUrl();\n  console.log(`Phoenix Socket URL: ${socketUrl}`);\n\n  const socketSettings: any = {};\n\n  if (debug) {\n    socketSettings.logger = (kind, msg, data) => {\n      console.log(`${kind}: ${msg}`, data);\n    };\n  }\n\n  if (params) {\n    socketSettings.params = params;\n  }\n\n  const socket = new socketClass(`${socketUrl}/socket`, socketSettings);\n  socket.connect();\n  socket.onError(async () => {\n    // On error, underlying reticulum node may have died, so rebalance by\n    // fetching a new healthy node to connect to.\n    invalidateReticulumMeta();\n\n    const endPointPath = new URL(socket.endPoint).pathname;\n    const newSocketUrl = await getNewSocketUrl();\n    const newEndPoint = `${newSocketUrl}${endPointPath}`;\n    console.log(`Socket error, changed endpoint to ${newEndPoint}`);\n    socket.endPoint = newEndPoint;\n  });\n\n  return socket;\n}\n\nexport function getPresenceEntryForSession(presences, sessionId) {\n  const entry =\n    Object.entries(presences || {}).find(([k]) => k === sessionId) || [];\n  const presence: any = entry[1];\n  return (presence && presence.metas && presence.metas[0]) || {};\n}\n\nexport function getPresenceContextForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).context || {};\n}\n\nexport function getPresenceProfileForSession(presences, sessionId) {\n  return (getPresenceEntryForSession(presences, sessionId) || {}).profile || {};\n}\n\nfunction migrateBindings(oldChannel, newChannel) {\n  const doNotDuplicate = [\n    \"phx_close\",\n    \"phx_error\",\n    \"phx_reply\",\n    \"presence_state\",\n    \"presence_diff\",\n  ];\n  const shouldDuplicate = (event) => {\n    return !event.startsWith(\"chan_reply_\") && !doNotDuplicate.includes(event);\n  };\n  for (let i = 0, l = oldChannel.bindings.length; i < l; i++) {\n    const item = oldChannel.bindings[i];\n    if (shouldDuplicate(item.event)) {\n      newChannel.bindings.push(item);\n    }\n  }\n  newChannel.bindingRef = oldChannel.bindingRef;\n}\n\n// Takes the given channel, and creates a new channel with the same bindings\n// with the given socket, joins it, and leaves the old channel after joining.\n//\n// NOTE: This function relies upon phoenix channel object internals, so this\n// function will need to be reviewed if/when we ever update phoenix.js\nexport function migrateChannelToSocket(oldChannel, socket, params) {\n  const channel = socket.channel(oldChannel.topic, params || oldChannel.params);\n\n  migrateBindings(oldChannel, channel);\n\n  for (let i = 0, l = oldChannel.pushBuffer.length; i < l; i++) {\n    const item = oldChannel.pushBuffer[i];\n    channel.push(item.event, item.payload, item.timeout);\n  }\n\n  const oldJoinPush = oldChannel.joinPush;\n  const joinPush = channel.join();\n\n  for (let i = 0, l = oldJoinPush.recHooks.length; i < l; i++) {\n    const item = oldJoinPush.recHooks[i];\n    joinPush.receive(item.status, item.callback);\n  }\n\n  return new Promise((resolve) => {\n    joinPush.receive(\"ok\", () => {\n      // Clear all event handlers first so no duplicate messages come in.\n      oldChannel.bindings = [];\n      resolve(channel);\n    });\n  });\n}\n\nexport function migrateToChannel(oldChannel, newChannel) {\n  migrateBindings(oldChannel, newChannel);\n\n  return new Promise((resolve, reject) => {\n    newChannel\n      .join()\n      .receive(\"ok\", (data) => {\n        oldChannel.leave();\n        oldChannel.bindings = [];\n        resolve(data);\n      })\n      .receive(\"error\", (data) => {\n        newChannel.leave();\n        reject(data);\n      });\n  });\n}\n\nexport function discordBridgesForPresences(presences: any[]) {\n  const channels = [];\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.profile && m.profile.discordBridges) {\n        Array.prototype.push.apply(\n          channels,\n          m.profile.discordBridges.map((b) => b.channel.name)\n        );\n      }\n    }\n  }\n  return channels;\n}\n\nexport function hasEmbedPresences(presences: any[]) {\n  for (const p of Object.values(presences)) {\n    for (const m of p.metas) {\n      if (m.context && m.context.embed) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function denoisePresence({ onJoin, onLeave, onChange }) {\n  return {\n    rawOnJoin: (key, beforeJoin, afterJoin) => {\n      if (beforeJoin === undefined) {\n        onJoin(key, afterJoin.metas[0]);\n      }\n    },\n    rawOnLeave: (key, remaining, removed) => {\n      if (remaining.metas.length === 0) {\n        onLeave(key, removed.metas[0]);\n      } else {\n        onChange(\n          key,\n          removed.metas[removed.metas.length - 1],\n          remaining.metas[remaining.metas.length - 1]\n        );\n      }\n    },\n  };\n}\n\nexport function presenceEventsForHub(events) {\n  const onJoin = (key, meta) => {\n    events.trigger(`hub:join`, { key, meta });\n  };\n  const onLeave = (key, meta) => {\n    events.trigger(`hub:leave`, { key, meta });\n  };\n  const onChange = (key, previous, current) => {\n    events.trigger(`hub:change`, { key, previous, current });\n  };\n  return {\n    onJoin,\n    onLeave,\n    onChange,\n  };\n}\n","import { loadAssets } from \"@root/lib/modules/core/loader/AssetsLoader\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\n\nexport default class SceneLoader {\n  private scene: any;\n  private mesh: any;\n  public navMesh: any;\n\n  constructor() {}\n\n  async loadScene(sceneUrl: string, threeLib: ThreeLib) {\n    this.scene = threeLib.scene;\n    this.mesh = await loadAssets(sceneUrl);\n    this.mesh = this.mesh.scene;\n\n    this.mesh.traverse((node) => {\n      if (node.isMesh) {\n        if (node.name === \"navMesh\") {\n          this.navMesh = node;\n        }\n      }\n    });\n\n    this.scene.add(this.mesh);\n  }\n}\n","import { load } from \"@root/lib/modules/spoke/PhoenixUtils\";\nimport Component from \"@root/lib/modules/core/ecs/Component\";\nimport SceneLoader from \"@root/lib/modules/spoke/SceneLoader\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\nimport { WebpackLazyModule } from \"@root/lib/modules/core/loader/WebpackLoader\";\nimport { ComponentFactory } from \"@root/lib/modules/core/ecs/ComponentFactory\";\nimport { WorldEntity } from \"@root/lib/modules/core/ecs/WorldEntity\";\nimport { ServiceEntity } from \"@root/lib/modules/core/service/ServiceEntity\";\nimport { PlayerService } from \"@root/lib/modules/controller/PlayerService\";\n\nexport class SpokeRoomLoader implements Component {\n  public sceneLoader: SceneLoader | null = null;\n\n  constructor(private threeLib: ThreeLib) {}\n\n  async loadRoom(hubid) {\n    const { data, hubPhxChannel, vapiddata } = await load(hubid);\n    const sceneURL = data.hubs[0].scene.model_url.replace(\".bin\", \".glb\");\n    this.sceneLoader = new SceneLoader();\n    await this.sceneLoader.loadScene(sceneURL, this.threeLib);\n  }\n\n  getType(): string {\n    return SpokeRoomLoader.name;\n  }\n}\n\nexport class Factory\n  implements WebpackLazyModule, ComponentFactory<SpokeRoomLoader>\n{\n  async create(world: WorldEntity, config: any): Promise<SpokeRoomLoader> {\n    let services = world.getFirstComponentByType<ServiceEntity>(\n      ServiceEntity.name\n    );\n    let three = await services.getService<ThreeLib>(\n      \"@root/lib/modules/three/ThreeLib\"\n    );\n    let playerService = await services.getService<PlayerService>(\n      \"@root/lib/modules/controller/PlayerService\"\n    );\n    let spokeRoomLoader = new SpokeRoomLoader(three);\n    await spokeRoomLoader.loadRoom(config.room);\n    if (spokeRoomLoader.sceneLoader) {\n      playerService\n        .getCurrentPlayer()\n        .declareNavMesh(spokeRoomLoader.sceneLoader.navMesh);\n    }\n    return spokeRoomLoader;\n  }\n}\n\n/*\nHave to connect to the phoenix websocket\nand get scene url from message from\n[\"2\", \"2\", \"hub:yUXD7A2\", \"phx_reply\", {\n    \"response\": {\n        \"hub_requires_oauth\": false,\n        \"hubs\": [{\n            \"allow_promotion\": true,\n            \"description\": null,\n            \"embed_token\": \"c223b27b9e6f48c5591b4b140fe7de6f\",\n            \"entry_code\": 180429,\n            \"entry_mode\": \"allow\",\n            \"host\": \"dedicatedwebrtc3.aptero.co\",\n            \"hub_id\": \"yUXD7A2\",\n            \"lobby_count\": 0,\n            \"member_count\": 0,\n            \"member_permissions\": {\n                \"fly\": true,\n                \"pin_objects\": true,\n                \"spawn_and_move_media\": true,\n                \"spawn_camera\": true,\n                \"spawn_drawing\": true,\n                \"spawn_emoji\": true\n            },\n            \"name\": \"Lightweight Empty Room\",\n            \"port\": \"443\",\n            \"room_size\": 50,\n            \"scene\": {\n                \"account_id\": null,\n                \"allow_promotion\": false,\n                \"allow_remixing\": false,\n                \"attribution\": null,\n                \"attributions\": { \"content\": [], \"creator\": \"\" },\n                \"description\": null,\n                \"model_url\": \"https://alphahub.aptero.co/files/598eeed3-0768-408a-a75b-b0fcb8e907af.bin\",\n                \"name\": \"Museum\",\n                \"parent_scene_id\": null,\n                \"project_id\": \"wwDyQ8t\",\n                \"scene_id\": \"br4pVT2\",\n                \"screenshot_url\": \"https://alphahub.aptero.co/files/38473f11-615f-487d-b20b-f3b6558abea6.jpg\",\n                \"type\": \"scene\",\n                \"url\": \"https://alphahub.aptero.co/scenes/br4pVT2/museum\"\n            },\n            \"slug\": \"lightweight-empty-room\",\n            \"turn\": {\n                \"credential\": \"CWBiIUroBx9x7OITbxMrm54HiJw=\",\n                \"enabled\": true,\n                \"transports\": [{ \"port\": 5349 }],\n                \"username\": \"1636140736:coturn\"\n            },\n            \"user_data\": null\n        }],\n        \"perms_token\": \"eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJhY2NvdW50X2lkIjoiNjQwNDA3MDUwOTY2MjY5OTYxIiwiYW1wbGlmeV9hdWRpbyI6dHJ1ZSwiYXVkIjoicmV0X3Blcm1zIiwiY2xvc2VfaHViIjp0cnVlLCJjcmVhdGVfaHViIjp0cnVlLCJlbWJlZF9odWIiOnRydWUsImV4cCI6MTYzNjE0MDkxNiwiZmx5Ijp0cnVlLCJodWJfaWQiOiJ5VVhEN0EyIiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqb2luX2h1YiI6dHJ1ZSwianRpIjoiZjhkNGU2MDMtMWE0NC00MWRmLTg5NWMtNjE3ZGVhYzc5ZDI4Iiwia2lja191c2VycyI6dHJ1ZSwibXV0ZV91c2VycyI6dHJ1ZSwibmJmIjoxNjM2MTQwNjE1LCJwaW5fb2JqZWN0cyI6dHJ1ZSwicG9zdGdyZXN0X3JvbGUiOiJyZXRfYWRtaW4iLCJzcGF3bl9hbmRfbW92ZV9tZWRpYSI6dHJ1ZSwic3Bhd25fY2FtZXJhIjp0cnVlLCJzcGF3bl9kcmF3aW5nIjp0cnVlLCJzcGF3bl9lbW9qaSI6dHJ1ZSwic3ViIjoiNjQwNDA3MDUwOTY2MjY5OTYxX3lVWEQ3QTIiLCJ0d2VldCI6ZmFsc2UsInR5cCI6ImFjY2VzcyIsInVwZGF0ZV9odWIiOnRydWUsInVwZGF0ZV9odWJfcHJvbW90aW9uIjp0cnVlLCJ1cGRhdGVfcm9sZXMiOnRydWV9.qlNJloKYDmc2wSTaKF1eVYKKV_lCuuwzfdRnq3Jc-OP9P5uhKiFzo1i9N6rHBCIfITEwp8fJouD7TNOrBvpwFgxR1JHTgOpgWTdD6ltxRGspbtJRMJQ7qa66WTrVxKup4fI1ah70dFIsHu26GNdUaaNp8503VYuo41Dzs0XnTT1bLjbNM0ugJ_ZaF_d24b1m_7dLKdAn0-aZkoTQSCl3wzNDKLE90B2FJT6Mc7hqeo8d0mhr3yNQSRyJ4xLS0TBG4fvFZQL5H_bRD4Fk-q17jeMAgIAvtquElbs1cYRnQFE3g-PcsRYYRsejWaz4PEJUlZ5MM5tbohM5XoVHdRT8ZA\",\n        \"session_id\": \"a3c750b8-6446-4a1e-a638-c516073d8861\",\n        \"session_token\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZXRfc2Vzc2lvbiIsImV4cCI6MTYzNjIyNzAxNiwiaWF0IjoxNjM2MTQwNjE2LCJpc3MiOiIiLCJqdGkiOiIzNDk4Yjg4OC01NjA0LTQxYzctYWFmZC0xMjI5NmU4YmNlYTIiLCJuYmYiOjE2MzYxNDA2MTUsInNlc3Npb25faWQiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJzdWIiOiJhM2M3NTBiOC02NDQ2LTRhMWUtYTYzOC1jNTE2MDczZDg4NjEiLCJ0eXAiOiJhY2Nlc3MifQ.EbEzkgwNJ8_H4g8vxFI-ch9HprbzNh12xkfj-OrUOkUqTF-j-qEpsF-XFIZozSlCU2cwJVD7RLuxNOuqDVF76g\",\n        \"subscriptions\": { \"favorites\": true, \"web_push\": null }\n    }, \"status\": \"ok\"\n}];\n\n */\n"],"names":["closure","value","globalSelf","self","phxWindow","window","global","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","TRANSPORTS","XHR_STATES","Push","constructor","channel","event","payload","timeout","this","receivedResp","timeoutTimer","recHooks","sent","resend","reset","send","hasReceived","startTimeout","socket","push","topic","ref","join_ref","joinRef","receive","status","callback","response","cancelRefEvent","refEvent","matchReceive","_ref","filter","h","forEach","off","cancelTimeout","clearTimeout","makeRef","replyEventName","on","setTimeout","trigger","Timer","timerCalc","timer","tries","scheduleTimeout","Ajax","method","endPoint","accept","body","ontimeout","XDomainRequest","req","xdomainRequest","XMLHttpRequest","xhrRequest","open","onload","parseJSON","responseText","onprogress","setRequestHeader","onerror","onreadystatechange","readyState","resp","JSON","parse","e","console","log","obj","parentKey","queryStr","key","Object","prototype","hasOwnProperty","call","paramKey","paramVal","serialize","encodeURIComponent","join","url","params","keys","length","prefix","match","LongPoll","token","skipHeartbeat","onopen","onmessage","onclose","pollEndpoint","normalizeEndpoint","poll","replace","RegExp","endpointURL","appendParams","closeAndRetry","close","request","bind","messages","msg","data","Error","_code","_reason","serializer_default","HEADER_LENGTH","META_LENGTH","KINDS","reply","broadcast","encode","ArrayBuffer","binaryEncode","stringify","decode","rawPayload","binaryDecode","message","metaLength","header","view","DataView","offset","setUint8","Array","from","char","charCodeAt","combined","Uint8Array","byteLength","set","buffer","kind","getUint8","decoder","TextDecoder","decodePush","decodeReply","decodeBroadcast","joinRefSize","topicSize","eventSize","slice","refSize","Socket","opts","stateChangeCallbacks","error","channels","sendBuffer","transport","WebSocket","establishedConnections","defaultEncoder","defaultDecoder","closeWasClean","binaryType","connectClock","awaitingConnectionOnPageShow","addEventListener","_e","conn","disconnect","connect","heartbeatIntervalMs","rejoinAfterMs","reconnectAfterMs","logger","longpollerTimeout","vsn","heartbeatTimer","pendingHeartbeatRef","reconnectTimer","teardown","replaceTransport","newTransport","protocol","location","endPointURL","uri","charAt","host","code","reason","onConnOpen","onConnError","onConnMessage","onConnClose","hasLogger","onOpen","onClose","onError","onMessage","flushSendBuffer","resetHeartbeat","heartbeatTimeout","abnormalClose","sendHeartbeat","waitForBufferDone","waitForSocketClosed","bufferedAmount","closeCode","triggerChanError","transportBefore","establishedBefore","isErrored","isLeaving","isClosed","connectionState","isConnected","remove","stateChangeRefs","c","refs","indexOf","chanParams","chan","state","bindings","bindingRef","joinedOnce","joinPush","pushBuffer","rejoinTimer","rejoin","pushEvent","isJoining","canPush","isJoined","leave","leavePush","_event","isMember","leaveOpenTopic","handledPayload","eventBindings","i","result","newRef","toString","rawMessage","dupChannel","find","configs","async","load","hubid","debug","socketClass","qs","URLSearchParams","search","getNewSocketUrl","refreshDirectReticulumHostAndPort","port","directReticulumHostAndPort","get","document","socketUrl","socketSettings","invalidateReticulumMeta","endPointPath","URL","pathname","newSocketUrl","newEndPoint","connectToReticulum","hubPhxChannel","vapiddata","Promise","resolve","reject","hub_id","profile","avatarId","displayName","push_subscription_endpoint","auth_token","perms_token","bot_access_key","context","mobile","embed","hub_invite_id","res","reticulumMeta","invalidatedReticulumMetaThisSession","SceneLoader","sceneUrl","threeLib","scene","mesh","loadAssets","traverse","node","isMesh","name","navMesh","add","SpokeRoomLoader","sceneURL","hubs","model_url","sceneLoader","loadScene","getType","Factory","world","config","services","getFirstComponentByType","ServiceEntity","three","getService","playerService","spokeRoomLoader","loadRoom","room","getCurrentPlayer","declareNavMesh"],"sourceRoot":""}