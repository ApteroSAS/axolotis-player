{"version":3,"file":"66.index.js","mappings":"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","sources":["webpack://axolotis-player/./src/lib/modules/ammo/AmmoLib.ts","webpack://axolotis-player/./src/lib/modules/scenes/demo2/LevelSetup.ts"],"sourcesContent":["import * as _Ammo from \"ammo.js/builds/ammo.wasm\";\nimport * as THREE from \"three\";\nimport { ConvexHull } from \"three/examples/jsm/math/ConvexHull\";\nvar config = {};\n\nlet Ammo: any = null;\nlet rayOrigin: any = null;\nlet rayDest: any = null;\nlet closestRayResultCallback: any = null;\n\nconst CollisionFlags = { CF_NO_CONTACT_RESPONSE: 4 };\nconst CollisionFilterGroups = {\n  DefaultFilter: 1,\n  StaticFilter: 2,\n  KinematicFilter: 4,\n  DebrisFilter: 8,\n  SensorTrigger: 16,\n  CharacterFilter: 32,\n  AllFilter: -1, //all bits sets: DefaultFilter | StaticFilter | KinematicFilter | DebrisFilter | SensorTrigger\n};\n\nfunction createConvexHullShape(object) {\n  const geometry = createConvexGeom(object);\n  let coords = geometry.attributes.position.array;\n  let tempVec = new Ammo.btVector3(0, 0, 0);\n  let shape = new Ammo.btConvexHullShape();\n  for (let i = 0, il = coords.length; i < il; i += 3) {\n    tempVec.setValue(coords[i], coords[i + 1], coords[i + 2]);\n    let lastOne = i >= il - 3;\n    shape.addPoint(tempVec, lastOne);\n  }\n  return shape;\n}\n\nfunction createConvexGeom(object) {\n  // Compute the 3D convex hull.\n  let hull = new ConvexHull().setFromObject(object);\n  let faces = hull.faces;\n  let vertices: any[] = [];\n  let normals: any[] = [];\n\n  for (var i = 0; i < faces.length; i++) {\n    var face = faces[i];\n    var edge = face.edge;\n    do {\n      let point: any = edge.head().point;\n      vertices.push(point.x, point.y, point.z);\n      normals.push(face.normal.x, face.normal.y, face.normal.z);\n      edge = edge.next;\n    } while (edge !== face.edge);\n  }\n\n  const geom = new THREE.BufferGeometry();\n  geom.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  geom.setAttribute(\"normal\", new THREE.Float32BufferAttribute(normals, 3));\n\n  return geom;\n}\n\nclass AmmoHelper {\n  static init(callback = () => {}) {\n    _Ammo(config).then((ammo) => {\n      Ammo = ammo;\n      callback();\n    });\n  }\n\n  static CreateTrigger(shape, position, rotation) {\n    const transform = new Ammo.btTransform();\n    transform.setIdentity();\n    position &&\n      transform.setOrigin(\n        new Ammo.btVector3(position.x, position.y, position.z)\n      );\n    rotation &&\n      transform.setRotation(\n        new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w)\n      );\n\n    const ghostObj = new Ammo.btPairCachingGhostObject();\n    ghostObj.setCollisionShape(shape);\n    ghostObj.setCollisionFlags(CollisionFlags.CF_NO_CONTACT_RESPONSE);\n    ghostObj.setWorldTransform(transform);\n\n    return ghostObj;\n  }\n\n  static IsTriggerOverlapping(ghostObj, rigidBody) {\n    for (let i = 0; i < ghostObj.getNumOverlappingObjects(); i++) {\n      const body = Ammo.castObject(\n        ghostObj.getOverlappingObject(i),\n        Ammo.btRigidBody\n      );\n      if (body == rigidBody) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static CastRay(\n    world,\n    origin,\n    dest,\n    result: any = {},\n    collisionFilterMask = CollisionFilterGroups.AllFilter\n  ) {\n    if (!rayOrigin) {\n      rayOrigin = new Ammo.btVector3();\n      rayDest = new Ammo.btVector3();\n      closestRayResultCallback = new Ammo.ClosestRayResultCallback(\n        rayOrigin,\n        rayDest\n      );\n    }\n\n    // Reset closestRayResultCallback to reuse it\n    const rayCallBack = Ammo.castObject(\n      closestRayResultCallback,\n      Ammo.RayResultCallback\n    );\n    rayCallBack.set_m_closestHitFraction(1);\n    rayCallBack.set_m_collisionObject(null);\n\n    rayCallBack.m_collisionFilterMask = collisionFilterMask;\n\n    // Set closestRayResultCallback origin and dest\n    rayOrigin.setValue(origin.x, origin.y, origin.z);\n    rayDest.setValue(dest.x, dest.y, dest.z);\n    closestRayResultCallback\n      .get_m_rayFromWorld()\n      .setValue(origin.x, origin.y, origin.z);\n    closestRayResultCallback\n      .get_m_rayToWorld()\n      .setValue(dest.x, dest.y, dest.z);\n\n    // Perform ray test\n    world.rayTest(rayOrigin, rayDest, closestRayResultCallback);\n\n    if (closestRayResultCallback.hasHit()) {\n      if (result.intersectionPoint) {\n        const point = closestRayResultCallback.get_m_hitPointWorld();\n        result.intersectionPoint.set(point.x(), point.y(), point.z());\n      }\n\n      if (result.intersectionNormal) {\n        const normal = closestRayResultCallback.get_m_hitNormalWorld();\n        result.intersectionNormal.set(normal.x(), normal.y(), normal.z());\n      }\n\n      result.collisionObject = rayCallBack.get_m_collisionObject();\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nexport {\n  AmmoHelper,\n  Ammo,\n  createConvexHullShape,\n  CollisionFlags,\n  CollisionFilterGroups,\n};\n","import Component from \"@root/lib/modules/core/ecs/Component\";\nimport { Ammo, createConvexHullShape } from \"@root/lib/modules/ammo/AmmoLib\";\nimport { AmmoPhysics } from \"@root/lib/modules/ammo/AmmoPhysics\";\nimport { loadAssets } from \"@root/lib/modules/core/loader/AssetsLoader\";\nimport { ThreeLib } from \"@root/lib/modules/three/ThreeLib\";\nimport { WebpackLazyModule } from \"@root/lib/modules/core/loader/WebpackLoader\";\nimport { ComponentFactory } from \"@root/lib/modules/core/ecs/ComponentFactory\";\nimport { WorldEntity } from \"@root/lib/modules/core/ecs/WorldEntity\";\nimport { ServiceEntity } from \"@root/lib/modules/core/service/ServiceEntity\";\n\nexport class Factory\n  implements WebpackLazyModule, ComponentFactory<LevelSetup>\n{\n  async create(world: WorldEntity, config: any): Promise<LevelSetup> {\n    let services = world.getFirstComponentByType<ServiceEntity>(\n      ServiceEntity.name\n    );\n    let three = await services.getService<ThreeLib>(\n      \"@root/lib/modules/three/ThreeLib\"\n    );\n    let ammo = await services.getService<AmmoPhysics>(\n      \"@root/lib/modules/core/ammo/AmmoPhysics\"\n    );\n    let module = new LevelSetup();\n    await module.loadScene(ammo, three);\n    return module;\n  }\n}\n\nexport default class LevelSetup implements Component {\n  private scene: any;\n  private physicsWorld: any;\n  private mesh: any;\n  constructor() {}\n\n  getType(): string {\n    return \"LevelSetup\";\n  }\n\n  async loadScene(ammoPhysics: AmmoPhysics, threeLib: ThreeLib) {\n    this.scene = threeLib.scene;\n    this.physicsWorld = ammoPhysics.physicsWorld;\n    this.mesh = await loadAssets(\"assets/static/demo2/level.glb\");\n    this.mesh = this.mesh.scene;\n\n    this.mesh.traverse((node) => {\n      if (node.isMesh || node.isLight) {\n        node.castShadow = true;\n      }\n      if (node.isMesh) {\n        node.receiveShadow = true;\n        //node.material.wireframe = true;\n        this.setStaticCollider(node);\n      }\n\n      if (node.isLight) {\n        node.intensity = 3;\n        const shadow = node.shadow;\n        const lightCam = shadow.camera;\n\n        shadow.mapSize.width = 1024 * 3;\n        shadow.mapSize.height = 1024 * 3;\n        shadow.bias = -0.00007;\n\n        const dH = 35,\n          dV = 35;\n        lightCam.left = -dH;\n        lightCam.right = dH;\n        lightCam.top = dV;\n        lightCam.bottom = -dV;\n\n        //const cameraHelper = new THREE.CameraHelper(lightCam);\n        //this.scene.add(cameraHelper);\n      }\n    });\n\n    this.scene.add(this.mesh);\n  }\n\n  setStaticCollider(mesh) {\n    const shape = createConvexHullShape(mesh);\n    const mass = 0;\n    const transform = new Ammo.btTransform();\n    transform.setIdentity();\n    const motionState = new Ammo.btDefaultMotionState(transform);\n\n    const localInertia = new Ammo.btVector3(0, 0, 0);\n    const rbInfo = new Ammo.btRigidBodyConstructionInfo(\n      mass,\n      motionState,\n      shape,\n      localInertia\n    );\n    const object = new Ammo.btRigidBody(rbInfo);\n    object.mesh = mesh;\n\n    this.physicsWorld.addRigidBody(object);\n  }\n}\n"],"names":["config","Ammo","rayOrigin","rayDest","closestRayResultCallback","CollisionFlags","CollisionFilterGroups","createConvexHullShape","object","coords","faces","ConvexHull","setFromObject","vertices","normals","i","length","face","edge","point","head","push","x","y","z","normal","next","geom","THREE","setAttribute","createConvexGeom","attributes","position","array","tempVec","btVector3","shape","btConvexHullShape","il","setValue","lastOne","addPoint","AmmoHelper","callback","_Ammo","then","ammo","rotation","transform","btTransform","setIdentity","setOrigin","setRotation","btQuaternion","w","ghostObj","btPairCachingGhostObject","setCollisionShape","setCollisionFlags","setWorldTransform","rigidBody","getNumOverlappingObjects","castObject","getOverlappingObject","btRigidBody","world","origin","dest","result","collisionFilterMask","ClosestRayResultCallback","rayCallBack","RayResultCallback","set_m_closestHitFraction","set_m_collisionObject","m_collisionFilterMask","get_m_rayFromWorld","get_m_rayToWorld","rayTest","hasHit","intersectionPoint","get_m_hitPointWorld","set","intersectionNormal","get_m_hitNormalWorld","collisionObject","get_m_collisionObject","Factory","services","getFirstComponentByType","ServiceEntity","three","getService","module","LevelSetup","loadScene","constructor","getType","ammoPhysics","threeLib","this","scene","physicsWorld","mesh","loadAssets","traverse","node","isMesh","isLight","castShadow","receiveShadow","setStaticCollider","intensity","shadow","lightCam","camera","mapSize","width","height","bias","dH","dV","left","right","top","bottom","add","motionState","localInertia","rbInfo","addRigidBody"],"sourceRoot":""}