{"version":3,"file":"534.index.js","mappings":"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","sources":["webpack://axolotis-player/./src/lib/modules/ammo/AmmoLib.ts","webpack://axolotis-player/./src/lib/modules/ammo/AmmoPhysics.ts"],"sourcesContent":["import * as _Ammo from \"ammo.js/builds/ammo.wasm\";\nimport * as THREE from \"three\";\nimport { ConvexHull } from \"three/examples/jsm/math/ConvexHull\";\nvar config = {};\n\nlet Ammo: any = null;\nlet rayOrigin: any = null;\nlet rayDest: any = null;\nlet closestRayResultCallback: any = null;\n\nconst CollisionFlags = { CF_NO_CONTACT_RESPONSE: 4 };\nconst CollisionFilterGroups = {\n  DefaultFilter: 1,\n  StaticFilter: 2,\n  KinematicFilter: 4,\n  DebrisFilter: 8,\n  SensorTrigger: 16,\n  CharacterFilter: 32,\n  AllFilter: -1, //all bits sets: DefaultFilter | StaticFilter | KinematicFilter | DebrisFilter | SensorTrigger\n};\n\nfunction createConvexHullShape(object) {\n  const geometry = createConvexGeom(object);\n  let coords = geometry.attributes.position.array;\n  let tempVec = new Ammo.btVector3(0, 0, 0);\n  let shape = new Ammo.btConvexHullShape();\n  for (let i = 0, il = coords.length; i < il; i += 3) {\n    tempVec.setValue(coords[i], coords[i + 1], coords[i + 2]);\n    let lastOne = i >= il - 3;\n    shape.addPoint(tempVec, lastOne);\n  }\n  return shape;\n}\n\nfunction createConvexGeom(object) {\n  // Compute the 3D convex hull.\n  let hull = new ConvexHull().setFromObject(object);\n  let faces = hull.faces;\n  let vertices: any[] = [];\n  let normals: any[] = [];\n\n  for (var i = 0; i < faces.length; i++) {\n    var face = faces[i];\n    var edge = face.edge;\n    do {\n      let point: any = edge.head().point;\n      vertices.push(point.x, point.y, point.z);\n      normals.push(face.normal.x, face.normal.y, face.normal.z);\n      edge = edge.next;\n    } while (edge !== face.edge);\n  }\n\n  const geom = new THREE.BufferGeometry();\n  geom.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  geom.setAttribute(\"normal\", new THREE.Float32BufferAttribute(normals, 3));\n\n  return geom;\n}\n\nclass AmmoHelper {\n  static init(callback = () => {}) {\n    _Ammo(config).then((ammo) => {\n      Ammo = ammo;\n      callback();\n    });\n  }\n\n  static CreateTrigger(shape, position, rotation) {\n    const transform = new Ammo.btTransform();\n    transform.setIdentity();\n    position &&\n      transform.setOrigin(\n        new Ammo.btVector3(position.x, position.y, position.z)\n      );\n    rotation &&\n      transform.setRotation(\n        new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w)\n      );\n\n    const ghostObj = new Ammo.btPairCachingGhostObject();\n    ghostObj.setCollisionShape(shape);\n    ghostObj.setCollisionFlags(CollisionFlags.CF_NO_CONTACT_RESPONSE);\n    ghostObj.setWorldTransform(transform);\n\n    return ghostObj;\n  }\n\n  static IsTriggerOverlapping(ghostObj, rigidBody) {\n    for (let i = 0; i < ghostObj.getNumOverlappingObjects(); i++) {\n      const body = Ammo.castObject(\n        ghostObj.getOverlappingObject(i),\n        Ammo.btRigidBody\n      );\n      if (body == rigidBody) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static CastRay(\n    world,\n    origin,\n    dest,\n    result: any = {},\n    collisionFilterMask = CollisionFilterGroups.AllFilter\n  ) {\n    if (!rayOrigin) {\n      rayOrigin = new Ammo.btVector3();\n      rayDest = new Ammo.btVector3();\n      closestRayResultCallback = new Ammo.ClosestRayResultCallback(\n        rayOrigin,\n        rayDest\n      );\n    }\n\n    // Reset closestRayResultCallback to reuse it\n    const rayCallBack = Ammo.castObject(\n      closestRayResultCallback,\n      Ammo.RayResultCallback\n    );\n    rayCallBack.set_m_closestHitFraction(1);\n    rayCallBack.set_m_collisionObject(null);\n\n    rayCallBack.m_collisionFilterMask = collisionFilterMask;\n\n    // Set closestRayResultCallback origin and dest\n    rayOrigin.setValue(origin.x, origin.y, origin.z);\n    rayDest.setValue(dest.x, dest.y, dest.z);\n    closestRayResultCallback\n      .get_m_rayFromWorld()\n      .setValue(origin.x, origin.y, origin.z);\n    closestRayResultCallback\n      .get_m_rayToWorld()\n      .setValue(dest.x, dest.y, dest.z);\n\n    // Perform ray test\n    world.rayTest(rayOrigin, rayDest, closestRayResultCallback);\n\n    if (closestRayResultCallback.hasHit()) {\n      if (result.intersectionPoint) {\n        const point = closestRayResultCallback.get_m_hitPointWorld();\n        result.intersectionPoint.set(point.x(), point.y(), point.z());\n      }\n\n      if (result.intersectionNormal) {\n        const normal = closestRayResultCallback.get_m_hitNormalWorld();\n        result.intersectionNormal.set(normal.x(), normal.y(), normal.z());\n      }\n\n      result.collisionObject = rayCallBack.get_m_collisionObject();\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nexport {\n  AmmoHelper,\n  Ammo,\n  createConvexHullShape,\n  CollisionFlags,\n  CollisionFilterGroups,\n};\n","import { Ammo, AmmoHelper } from \"./AmmoLib\";\nimport Component from \"@root/lib/modules/core/ecs/Component\";\nimport { FrameLoop } from \"@root/lib/modules/FrameLoop\";\nimport { WebpackLazyModule } from \"@root/lib/modules/core/loader/WebpackLoader\";\nimport {\n  LazyServices,\n  Service,\n} from \"@root/lib/modules/core/service/LazyServices\";\n\nexport class AmmoPhysics implements Component {\n  physicsUpdate = (world, timeStep) => {\n    //this.entityManager.PhysicsUpdate(world, timeStep);\n  };\n  public physicsWorld: any;\n\n  async setupPhysics() {\n    return new Promise((resolve) => {\n      AmmoHelper.init(() => {\n        // Physics configuration\n        const collisionConfiguration =\n          new Ammo.btDefaultCollisionConfiguration();\n        const dispatcher = new Ammo.btCollisionDispatcher(\n          collisionConfiguration\n        );\n        const broadphase = new Ammo.btDbvtBroadphase();\n        const solver = new Ammo.btSequentialImpulseConstraintSolver();\n        this.physicsWorld = new Ammo.btDiscreteDynamicsWorld(\n          dispatcher,\n          broadphase,\n          solver,\n          collisionConfiguration\n        );\n        this.physicsWorld.setGravity(new Ammo.btVector3(0.0, -9.81, 0.0));\n        //const fp = Ammo.addFunction(this.physicsUpdate);\n        //this.physicsWorld.setInternalTickCallback(fp);\n        this.physicsWorld\n          .getBroadphase()\n          .getOverlappingPairCache()\n          .setInternalGhostPairCallback(new Ammo.btGhostPairCallback());\n\n        //Physics debug drawer\n        //this.debugDrawer = new DebugDrawer(this.scene, this.physicsWorld);\n        //this.debugDrawer.enable();\n        resolve(true);\n      });\n    });\n  }\n\n  step(elapsedTime) {\n    this.physicsWorld.stepSimulation(elapsedTime, 10);\n  }\n\n  getAmmo() {\n    return Ammo;\n  }\n\n  getType(): string {\n    return AmmoPhysics.name;\n  }\n}\n\nexport class Factory implements WebpackLazyModule, Service<AmmoPhysics> {\n  async create(services: LazyServices): Promise<AmmoPhysics> {\n    let frameLoop = await services.getService<FrameLoop>(\n      \"@root/lib/modules/FrameLoop\"\n    );\n    const ammo = new AmmoPhysics();\n    await ammo.setupPhysics();\n    (await frameLoop).addLoop(AmmoPhysics.name, (delta) => {\n      ammo.step(delta * 0.001);\n    });\n    return ammo;\n  }\n}\n"],"names":["config","Ammo","rayOrigin","rayDest","closestRayResultCallback","CollisionFlags","CollisionFilterGroups","createConvexHullShape","object","coords","faces","ConvexHull","setFromObject","vertices","normals","i","length","face","edge","point","head","push","x","y","z","normal","next","geom","THREE","setAttribute","createConvexGeom","attributes","position","array","tempVec","btVector3","shape","btConvexHullShape","il","setValue","lastOne","addPoint","AmmoHelper","callback","_Ammo","then","ammo","rotation","transform","btTransform","setIdentity","setOrigin","setRotation","btQuaternion","w","ghostObj","btPairCachingGhostObject","setCollisionShape","setCollisionFlags","setWorldTransform","rigidBody","getNumOverlappingObjects","castObject","getOverlappingObject","btRigidBody","world","origin","dest","result","collisionFilterMask","ClosestRayResultCallback","rayCallBack","RayResultCallback","set_m_closestHitFraction","set_m_collisionObject","m_collisionFilterMask","get_m_rayFromWorld","get_m_rayToWorld","rayTest","hasHit","intersectionPoint","get_m_hitPointWorld","set","intersectionNormal","get_m_hitNormalWorld","collisionObject","get_m_collisionObject","AmmoPhysics","timeStep","Promise","resolve","collisionConfiguration","dispatcher","broadphase","solver","this","physicsWorld","setGravity","getBroadphase","getOverlappingPairCache","setInternalGhostPairCallback","step","elapsedTime","stepSimulation","getAmmo","getType","name","Factory","services","frameLoop","getService","setupPhysics","addLoop","delta"],"sourceRoot":""}